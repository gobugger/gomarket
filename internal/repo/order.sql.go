// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package repo

import (
	"context"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
	details, total_price_pico, customer_id, delivery_method_id, vendor_id
)
SELECT
	$1, $2, $3, $4, dm.vendor_id
FROM delivery_methods AS dm
WHERE dm.id = $4
RETURNING id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at
`

type CreateOrderParams struct {
	Details          string
	TotalPricePico   int64
	CustomerID       uuid.UUID
	DeliveryMethodID uuid.UUID
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.Details,
		arg.TotalPricePico,
		arg.CustomerID,
		arg.DeliveryMethodID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Details,
		&i.TotalPricePico,
		&i.DeliveryMethodID,
		&i.VendorID,
		&i.CustomerID,
		&i.NumExtends,
		&i.CreatedAt,
		&i.PaidAt,
		&i.AcceptedAt,
		&i.DispatchedAt,
		&i.FinalizedAt,
		&i.DisputedAt,
	)
	return i, err
}

const createOrderInvoice = `-- name: CreateOrderInvoice :one
INSERT INTO order_invoices (
	order_id, invoice_id
)
VALUES (
	$1, $2
)
RETURNING id, order_id, invoice_id
`

type CreateOrderInvoiceParams struct {
	OrderID   uuid.UUID
	InvoiceID uuid.UUID
}

func (q *Queries) CreateOrderInvoice(ctx context.Context, arg CreateOrderInvoiceParams) (OrderInvoice, error) {
	row := q.db.QueryRow(ctx, createOrderInvoice, arg.OrderID, arg.InvoiceID)
	var i OrderInvoice
	err := row.Scan(&i.ID, &i.OrderID, &i.InvoiceID)
	return i, err
}

type CreateOrderItemsParams struct {
	OrderID uuid.UUID
	PriceID uuid.UUID
	Count   int32
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const extendOrder = `-- name: ExtendOrder :one
UPDATE orders
SET num_extends = num_extends + 1
WHERE id = $1 AND num_extends < 2
RETURNING num_extends
`

func (q *Queries) ExtendOrder(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, extendOrder, id)
	var num_extends int32
	err := row.Scan(&num_extends)
	return num_extends, err
}

const getCustomerForOrder = `-- name: GetCustomerForOrder :one
SELECT users.id, users.username, users.password_hash, users.pgp_key, users.prev_login, users.locale, users.currency, users.twofa_enabled, users.incognito_enabled, users.created_at
FROM orders
JOIN users ON users.id = orders.customer_id
WHERE orders.id = $1
`

func (q *Queries) GetCustomerForOrder(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getCustomerForOrder, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.PgpKey,
		&i.PrevLogin,
		&i.Locale,
		&i.Currency,
		&i.TwofaEnabled,
		&i.IncognitoEnabled,
		&i.CreatedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at FROM orders
WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Details,
		&i.TotalPricePico,
		&i.DeliveryMethodID,
		&i.VendorID,
		&i.CustomerID,
		&i.NumExtends,
		&i.CreatedAt,
		&i.PaidAt,
		&i.AcceptedAt,
		&i.DispatchedAt,
		&i.FinalizedAt,
		&i.DisputedAt,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT order_items.id, order_items.order_id, order_items.price_id, order_items.count, price_tiers.product_id, price_tiers.quantity, price_tiers.price_cent
FROM order_items
JOIN price_tiers ON price_tiers.id = order_items.price_id
WHERE order_id = $1
`

type GetOrderItemsRow struct {
	ID        uuid.UUID
	OrderID   uuid.UUID
	PriceID   uuid.UUID
	Count     int32
	ProductID uuid.UUID
	Quantity  int32
	PriceCent int64
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.PriceID,
			&i.Count,
			&i.ProductID,
			&i.Quantity,
			&i.PriceCent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatusXInvoiceStatus = `-- name: GetOrdersByStatusXInvoiceStatus :many
SELECT orders.id, orders.status, orders.details, orders.total_price_pico, orders.delivery_method_id, orders.vendor_id, orders.customer_id, orders.num_extends, orders.created_at, orders.paid_at, orders.accepted_at, orders.dispatched_at, orders.finalized_at, orders.disputed_at
FROM order_invoices
JOIN orders ON orders.id = order_invoices.order_id AND orders.status = $1::order_status
JOIN invoices ON invoices.id = order_invoices.invoice_id AND invoices.status = $2::invoice_status
`

type GetOrdersByStatusXInvoiceStatusParams struct {
	OrderStatus   OrderStatus
	InvoiceStatus InvoiceStatus
}

func (q *Queries) GetOrdersByStatusXInvoiceStatus(ctx context.Context, arg GetOrdersByStatusXInvoiceStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatusXInvoiceStatus, arg.OrderStatus, arg.InvoiceStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Details,
			&i.TotalPricePico,
			&i.DeliveryMethodID,
			&i.VendorID,
			&i.CustomerID,
			&i.NumExtends,
			&i.CreatedAt,
			&i.PaidAt,
			&i.AcceptedAt,
			&i.DispatchedAt,
			&i.FinalizedAt,
			&i.DisputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersForCustomer = `-- name: GetOrdersForCustomer :many
SELECT id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at FROM orders
WHERE customer_id = $1
`

func (q *Queries) GetOrdersForCustomer(ctx context.Context, customerID uuid.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersForCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Details,
			&i.TotalPricePico,
			&i.DeliveryMethodID,
			&i.VendorID,
			&i.CustomerID,
			&i.NumExtends,
			&i.CreatedAt,
			&i.PaidAt,
			&i.AcceptedAt,
			&i.DispatchedAt,
			&i.FinalizedAt,
			&i.DisputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersForVendor = `-- name: GetOrdersForVendor :many
SELECT orders.id, orders.status, orders.details, orders.total_price_pico, orders.delivery_method_id, orders.vendor_id, orders.customer_id, orders.num_extends, orders.created_at, orders.paid_at, orders.accepted_at, orders.dispatched_at, orders.finalized_at, orders.disputed_at FROM orders
WHERE orders.vendor_id = $1
`

func (q *Queries) GetOrdersForVendor(ctx context.Context, vendorID uuid.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersForVendor, vendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Details,
			&i.TotalPricePico,
			&i.DeliveryMethodID,
			&i.VendorID,
			&i.CustomerID,
			&i.NumExtends,
			&i.CreatedAt,
			&i.PaidAt,
			&i.AcceptedAt,
			&i.DispatchedAt,
			&i.FinalizedAt,
			&i.DisputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithStatus = `-- name: GetOrdersWithStatus :many
SELECT id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at FROM orders
WHERE status = $1
`

func (q *Queries) GetOrdersWithStatus(ctx context.Context, status OrderStatus) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersWithStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Details,
			&i.TotalPricePico,
			&i.DeliveryMethodID,
			&i.VendorID,
			&i.CustomerID,
			&i.NumExtends,
			&i.CreatedAt,
			&i.PaidAt,
			&i.AcceptedAt,
			&i.DispatchedAt,
			&i.FinalizedAt,
			&i.DisputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithStatuses = `-- name: GetOrdersWithStatuses :many
SELECT id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at
FROM orders
WHERE status = ANY($1::order_status[])
`

func (q *Queries) GetOrdersWithStatuses(ctx context.Context, statuses []OrderStatus) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersWithStatuses, statuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Details,
			&i.TotalPricePico,
			&i.DeliveryMethodID,
			&i.VendorID,
			&i.CustomerID,
			&i.NumExtends,
			&i.CreatedAt,
			&i.PaidAt,
			&i.AcceptedAt,
			&i.DispatchedAt,
			&i.FinalizedAt,
			&i.DisputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVendorForOrder = `-- name: GetVendorForOrder :one
SELECT users.id, users.username, users.password_hash, users.pgp_key, users.prev_login, users.locale, users.currency, users.twofa_enabled, users.incognito_enabled, users.created_at
FROM orders 
JOIN users ON users.id = orders.vendor_id	
WHERE orders.id = $1
`

func (q *Queries) GetVendorForOrder(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getVendorForOrder, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.PgpKey,
		&i.PrevLogin,
		&i.Locale,
		&i.Currency,
		&i.TwofaEnabled,
		&i.IncognitoEnabled,
		&i.CreatedAt,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2
WHERE id = $1 AND status = ANY($3::order_status[])
RETURNING id, status, details, total_price_pico, delivery_method_id, vendor_id, customer_id, num_extends, created_at, paid_at, accepted_at, dispatched_at, finalized_at, disputed_at
`

type UpdateOrderStatusParams struct {
	ID            uuid.UUID
	Status        OrderStatus
	ValidStatuses []OrderStatus
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status, arg.ValidStatuses)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Details,
		&i.TotalPricePico,
		&i.DeliveryMethodID,
		&i.VendorID,
		&i.CustomerID,
		&i.NumExtends,
		&i.CreatedAt,
		&i.PaidAt,
		&i.AcceptedAt,
		&i.DispatchedAt,
		&i.FinalizedAt,
		&i.DisputedAt,
	)
	return i, err
}
