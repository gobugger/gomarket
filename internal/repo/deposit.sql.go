// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deposit.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createDeposit = `-- name: CreateDeposit :one
INSERT INTO deposits (
	wallet_id, invoice_id
) VALUES(
	$1, $2
) RETURNING id, wallet_id, invoice_id, amount_deposited_pico
`

type CreateDepositParams struct {
	WalletID  uuid.UUID
	InvoiceID uuid.UUID
}

func (q *Queries) CreateDeposit(ctx context.Context, arg CreateDepositParams) (Deposit, error) {
	row := q.db.QueryRow(ctx, createDeposit, arg.WalletID, arg.InvoiceID)
	var i Deposit
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.InvoiceID,
		&i.AmountDepositedPico,
	)
	return i, err
}

const getDepositForUser = `-- name: GetDepositForUser :one
SELECT wallets.id, wallets.balance_pico, wallets.user_id, invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at
FROM deposits
JOIN wallets ON wallets.id = deposits.wallet_id
JOIN invoices ON invoices.id = deposits.invoice_id
WHERE wallets.user_id = $1
`

type GetDepositForUserRow struct {
	Wallet  Wallet
	Invoice Invoice
}

func (q *Queries) GetDepositForUser(ctx context.Context, userID uuid.UUID) (GetDepositForUserRow, error) {
	row := q.db.QueryRow(ctx, getDepositForUser, userID)
	var i GetDepositForUserRow
	err := row.Scan(
		&i.Wallet.ID,
		&i.Wallet.BalancePico,
		&i.Wallet.UserID,
		&i.Invoice.ID,
		&i.Invoice.Address,
		&i.Invoice.AmountPico,
		&i.Invoice.Status,
		&i.Invoice.AmountUnlockedPico,
		&i.Invoice.Permanent,
		&i.Invoice.CreatedAt,
	)
	return i, err
}

const getDepositForWallet = `-- name: GetDepositForWallet :one
SELECT wallets.id, wallets.balance_pico, wallets.user_id, invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at
FROM deposits
JOIN wallets ON wallets.id = deposits.wallet_id
JOIN invoices ON invoices.id = deposits.invoice_id
WHERE deposits.wallet_id = $1
`

type GetDepositForWalletRow struct {
	Wallet  Wallet
	Invoice Invoice
}

func (q *Queries) GetDepositForWallet(ctx context.Context, walletID uuid.UUID) (GetDepositForWalletRow, error) {
	row := q.db.QueryRow(ctx, getDepositForWallet, walletID)
	var i GetDepositForWalletRow
	err := row.Scan(
		&i.Wallet.ID,
		&i.Wallet.BalancePico,
		&i.Wallet.UserID,
		&i.Invoice.ID,
		&i.Invoice.Address,
		&i.Invoice.AmountPico,
		&i.Invoice.Status,
		&i.Invoice.AmountUnlockedPico,
		&i.Invoice.Permanent,
		&i.Invoice.CreatedAt,
	)
	return i, err
}

const getOutdatedDeposits = `-- name: GetOutdatedDeposits :many
SELECT deposits.id, deposits.wallet_id, deposits.invoice_id, deposits.amount_deposited_pico, invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at
FROM deposits
JOIN invoices ON invoices.id = deposits.invoice_id
WHERE deposits.amount_deposited_pico < invoices.amount_unlocked_pico
FOR UPDATE
`

type GetOutdatedDepositsRow struct {
	ID                  uuid.UUID
	WalletID            uuid.UUID
	InvoiceID           uuid.UUID
	AmountDepositedPico int64
	ID_2                uuid.UUID
	Address             string
	AmountPico          int64
	Status              InvoiceStatus
	AmountUnlockedPico  int64
	Permanent           bool
	CreatedAt           time.Time
}

func (q *Queries) GetOutdatedDeposits(ctx context.Context) ([]GetOutdatedDepositsRow, error) {
	rows, err := q.db.Query(ctx, getOutdatedDeposits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutdatedDepositsRow
	for rows.Next() {
		var i GetOutdatedDepositsRow
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.InvoiceID,
			&i.AmountDepositedPico,
			&i.ID_2,
			&i.Address,
			&i.AmountPico,
			&i.Status,
			&i.AmountUnlockedPico,
			&i.Permanent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAmountDeposited = `-- name: UpdateAmountDeposited :one
UPDATE deposits
SET amount_deposited_pico = $2
WHERE id = $1
RETURNING id, wallet_id, invoice_id, amount_deposited_pico
`

type UpdateAmountDepositedParams struct {
	ID                  uuid.UUID
	AmountDepositedPico int64
}

func (q *Queries) UpdateAmountDeposited(ctx context.Context, arg UpdateAmountDepositedParams) (Deposit, error) {
	row := q.db.QueryRow(ctx, updateAmountDeposited, arg.ID, arg.AmountDepositedPico)
	var i Deposit
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.InvoiceID,
		&i.AmountDepositedPico,
	)
	return i, err
}
