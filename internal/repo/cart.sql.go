// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items
WHERE customer_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, customerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearCart, customerID)
	return err
}

const createCartItem = `-- name: CreateCartItem :one
INSERT INTO cart_items (
	customer_id, price_id
) VALUES (
	$1, $2
) RETURNING id, customer_id, price_id, created_at
`

type CreateCartItemParams struct {
	CustomerID uuid.UUID
	PriceID    uuid.UUID
}

func (q *Queries) CreateCartItem(ctx context.Context, arg CreateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, createCartItem, arg.CustomerID, arg.PriceID)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PriceID,
		&i.CreatedAt,
	)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT id, customer_id, price_id, created_at FROM cart_items
WHERE customer_id = $1
`

func (q *Queries) GetCartItems(ctx context.Context, customerID uuid.UUID) ([]CartItem, error) {
	rows, err := q.db.Query(ctx, getCartItems, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CartItem
	for rows.Next() {
		var i CartItem
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.PriceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartItemsByVendor = `-- name: GetCartItemsByVendor :many
SELECT cart_items.id, customer_id, price_id, created_at, price_tiers.id, product_id, quantity, price_cent, price_tiers.deleted_at, products.id, title, description, category_id, inventory, ships_from, ships_to, vendor_id, products.deleted_at 
FROM cart_items
JOIN price_tiers ON price_tiers.id = cart_items.price_id
JOIN products ON products.id = price_tiers.product_id AND products.vendor_id = $2
WHERE cart_items.customer_id = $1
`

type GetCartItemsByVendorParams struct {
	CustomerID uuid.UUID
	VendorID   uuid.UUID
}

type GetCartItemsByVendorRow struct {
	ID          uuid.UUID
	CustomerID  uuid.UUID
	PriceID     uuid.UUID
	CreatedAt   time.Time
	ID_2        uuid.UUID
	ProductID   uuid.UUID
	Quantity    int32
	PriceCent   int64
	DeletedAt   pgtype.Timestamptz
	ID_3        uuid.UUID
	Title       string
	Description string
	CategoryID  uuid.UUID
	Inventory   int32
	ShipsFrom   string
	ShipsTo     string
	VendorID    uuid.UUID
	DeletedAt_2 pgtype.Timestamptz
}

func (q *Queries) GetCartItemsByVendor(ctx context.Context, arg GetCartItemsByVendorParams) ([]GetCartItemsByVendorRow, error) {
	rows, err := q.db.Query(ctx, getCartItemsByVendor, arg.CustomerID, arg.VendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsByVendorRow
	for rows.Next() {
		var i GetCartItemsByVendorRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.PriceID,
			&i.CreatedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Quantity,
			&i.PriceCent,
			&i.DeletedAt,
			&i.ID_3,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.Inventory,
			&i.ShipsFrom,
			&i.ShipsTo,
			&i.VendorID,
			&i.DeletedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartPriceTiersForCustomer = `-- name: GetCartPriceTiersForCustomer :many
SELECT price_tiers.id, price_tiers.product_id, price_tiers.quantity, price_tiers.price_cent, price_tiers.deleted_at 
FROM price_tiers
JOIN products ON products.id = price_tiers.product_id AND products.vendor_id = $2
WHERE price_tiers.id IN (SELECT price_id FROM cart_items WHERE customer_id = $1)
FOR UPDATE
`

type GetCartPriceTiersForCustomerParams struct {
	CustomerID uuid.UUID
	VendorID   uuid.UUID
}

func (q *Queries) GetCartPriceTiersForCustomer(ctx context.Context, arg GetCartPriceTiersForCustomerParams) ([]PriceTier, error) {
	rows, err := q.db.Query(ctx, getCartPriceTiersForCustomer, arg.CustomerID, arg.VendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PriceTier
	for rows.Next() {
		var i PriceTier
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.PriceCent,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumCartItemsForCustomer = `-- name: GetNumCartItemsForCustomer :one
SELECT COUNT(*)
FROM cart_items
WHERE cart_items.customer_id = $1
`

func (q *Queries) GetNumCartItemsForCustomer(ctx context.Context, customerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getNumCartItemsForCustomer, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeCartItem = `-- name: RemoveCartItem :exec
DELETE FROM cart_items
WHERE id = (
	SELECT id
	FROM cart_items
	WHERE cart_items.customer_id = $1 AND cart_items.price_id = $2
	LIMIT 1
)
`

type RemoveCartItemParams struct {
	CustomerID uuid.UUID
	PriceID    uuid.UUID
}

func (q *Queries) RemoveCartItem(ctx context.Context, arg RemoveCartItemParams) error {
	_, err := q.db.Exec(ctx, removeCartItem, arg.CustomerID, arg.PriceID)
	return err
}

const removeCartItems = `-- name: RemoveCartItems :exec
DELETE FROM cart_items
WHERE cart_items.customer_id = $1 AND $2 = (
	SELECT products.vendor_id
	FROM price_tiers
	JOIN products ON products.id = price_tiers.product_id
	WHERE price_tiers.id = cart_items.price_id
)
`

type RemoveCartItemsParams struct {
	CustomerID uuid.UUID
	VendorID   uuid.UUID
}

func (q *Queries) RemoveCartItems(ctx context.Context, arg RemoveCartItemsParams) error {
	_, err := q.db.Exec(ctx, removeCartItems, arg.CustomerID, arg.VendorID)
	return err
}

const setCartItemInvalid = `-- name: SetCartItemInvalid :exec
UPDATE cart_items
SET invalid = true
WHERE id = $1
`

func (q *Queries) SetCartItemInvalid(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setCartItemInvalid, id)
	return err
}
