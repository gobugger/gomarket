// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: review.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createProductReview = `-- name: CreateProductReview :one
INSERT INTO product_reviews (
    grade, comment, order_item_id
) 
VALUES (
    $1, $2, $3
) RETURNING id, grade, comment, order_item_id
`

type CreateProductReviewParams struct {
	Grade       int32
	Comment     string
	OrderItemID uuid.UUID
}

func (q *Queries) CreateProductReview(ctx context.Context, arg CreateProductReviewParams) (ProductReview, error) {
	row := q.db.QueryRow(ctx, createProductReview, arg.Grade, arg.Comment, arg.OrderItemID)
	var i ProductReview
	err := row.Scan(
		&i.ID,
		&i.Grade,
		&i.Comment,
		&i.OrderItemID,
	)
	return i, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (
    grade, comment, order_id
) 
VALUES (
    $1, $2, $3
) RETURNING id, grade, comment, order_id, created_at
`

type CreateReviewParams struct {
	Grade   int32
	Comment string
	OrderID uuid.UUID
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.db.QueryRow(ctx, createReview, arg.Grade, arg.Comment, arg.OrderID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.Grade,
		&i.Comment,
		&i.OrderID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews
WHERE id = $1
`

func (q *Queries) DeleteReview(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteReview, id)
	return err
}

const getReviewsForProduct = `-- name: GetReviewsForProduct :many
SELECT product_reviews.id, product_reviews.grade, product_reviews.comment, product_reviews.order_item_id,
	price_tiers.quantity * order_items.count AS total_quantity,
	price_tiers.price_cent * order_items.count AS total_price_cent,
	users.username AS author_name,
	reviews.created_at AS created_at
FROM product_reviews
JOIN order_items ON order_items.id = product_reviews.order_item_id
JOIN price_tiers ON price_tiers.id = order_items.price_id
JOIN orders ON orders.id = order_items.order_id
JOIN reviews ON reviews.order_id = orders.id
JOIN users ON users.id = orders.customer_id
WHERE price_tiers.product_id = $1
`

type GetReviewsForProductRow struct {
	ProductReview  ProductReview
	TotalQuantity  int32
	TotalPriceCent int32
	AuthorName     string
	CreatedAt      time.Time
}

func (q *Queries) GetReviewsForProduct(ctx context.Context, productID uuid.UUID) ([]GetReviewsForProductRow, error) {
	rows, err := q.db.Query(ctx, getReviewsForProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsForProductRow
	for rows.Next() {
		var i GetReviewsForProductRow
		if err := rows.Scan(
			&i.ProductReview.ID,
			&i.ProductReview.Grade,
			&i.ProductReview.Comment,
			&i.ProductReview.OrderItemID,
			&i.TotalQuantity,
			&i.TotalPriceCent,
			&i.AuthorName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsForVendor = `-- name: GetReviewsForVendor :many
SELECT reviews.id, reviews.grade, reviews.comment, reviews.order_id, reviews.created_at, users.id, users.username, users.password_hash, users.pgp_key, users.prev_login, users.locale, users.currency, users.twofa_enabled, users.incognito_enabled, users.created_at
FROM orders
JOIN reviews ON reviews.order_id = orders.id
JOIN users ON users.id = orders.customer_id
WHERE orders.vendor_id = $1
`

type GetReviewsForVendorRow struct {
	Review Review
	User   User
}

func (q *Queries) GetReviewsForVendor(ctx context.Context, vendorID uuid.UUID) ([]GetReviewsForVendorRow, error) {
	rows, err := q.db.Query(ctx, getReviewsForVendor, vendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsForVendorRow
	for rows.Next() {
		var i GetReviewsForVendorRow
		if err := rows.Scan(
			&i.Review.ID,
			&i.Review.Grade,
			&i.Review.Comment,
			&i.Review.OrderID,
			&i.Review.CreatedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.PasswordHash,
			&i.User.PgpKey,
			&i.User.PrevLogin,
			&i.User.Locale,
			&i.User.Currency,
			&i.User.TwofaEnabled,
			&i.User.IncognitoEnabled,
			&i.User.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
