// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: views.sql

package repo

import (
	"context"

	"github.com/google/uuid"
)

const getViewCartForCustomer = `-- name: GetViewCartForCustomer :many
SELECT price_tiers.id AS price_tier_id,
	products.id, products.title, products.description, products.category_id, products.inventory, products.ships_from, products.ships_to, products.vendor_id, products.deleted_at,
	vendors.id, vendors.username, vendors.password_hash, vendors.pgp_key, vendors.prev_login, vendors.locale, vendors.currency, vendors.twofa_enabled, vendors.incognito_enabled, vendors.created_at,
	price_tiers.price_cent,
	price_tiers.quantity,
	COUNT(cart_items.price_id)
FROM cart_items
JOIN price_tiers ON price_tiers.id = cart_items.price_id
JOIN products ON products.id = price_tiers.product_id
JOIN users AS vendors ON vendors.id = products.vendor_id
WHERE cart_items.customer_id = $1
GROUP BY price_tiers.id, products.id, vendors.id, price_tiers.price_cent, price_tiers.quantity
`

type GetViewCartForCustomerRow struct {
	PriceTierID uuid.UUID
	Product     Product
	User        User
	PriceCent   int64
	Quantity    int32
	Count       int64
}

func (q *Queries) GetViewCartForCustomer(ctx context.Context, customerID uuid.UUID) ([]GetViewCartForCustomerRow, error) {
	rows, err := q.db.Query(ctx, getViewCartForCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewCartForCustomerRow
	for rows.Next() {
		var i GetViewCartForCustomerRow
		if err := rows.Scan(
			&i.PriceTierID,
			&i.Product.ID,
			&i.Product.Title,
			&i.Product.Description,
			&i.Product.CategoryID,
			&i.Product.Inventory,
			&i.Product.ShipsFrom,
			&i.Product.ShipsTo,
			&i.Product.VendorID,
			&i.Product.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.PasswordHash,
			&i.User.PgpKey,
			&i.User.PrevLogin,
			&i.User.Locale,
			&i.User.Currency,
			&i.User.TwofaEnabled,
			&i.User.IncognitoEnabled,
			&i.User.CreatedAt,
			&i.PriceCent,
			&i.Quantity,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewCartForCustomerByVendor = `-- name: GetViewCartForCustomerByVendor :many
SELECT price_tiers.id AS price_tier_id,
	products.id, products.title, products.description, products.category_id, products.inventory, products.ships_from, products.ships_to, products.vendor_id, products.deleted_at,
	vendors.id, vendors.username, vendors.password_hash, vendors.pgp_key, vendors.prev_login, vendors.locale, vendors.currency, vendors.twofa_enabled, vendors.incognito_enabled, vendors.created_at,
	price_tiers.price_cent,
	price_tiers.quantity,
	COUNT(cart_items.price_id)
FROM cart_items
JOIN price_tiers ON price_tiers.id = cart_items.price_id
JOIN products ON products.id = price_tiers.product_id AND products.vendor_id = $2
JOIN users AS vendors ON vendors.id = products.vendor_id
WHERE cart_items.customer_id = $1
GROUP BY price_tiers.id, products.id, vendors.id, price_tiers.price_cent, price_tiers.quantity
`

type GetViewCartForCustomerByVendorParams struct {
	CustomerID uuid.UUID
	VendorID   uuid.UUID
}

type GetViewCartForCustomerByVendorRow struct {
	PriceTierID uuid.UUID
	Product     Product
	User        User
	PriceCent   int64
	Quantity    int32
	Count       int64
}

func (q *Queries) GetViewCartForCustomerByVendor(ctx context.Context, arg GetViewCartForCustomerByVendorParams) ([]GetViewCartForCustomerByVendorRow, error) {
	rows, err := q.db.Query(ctx, getViewCartForCustomerByVendor, arg.CustomerID, arg.VendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewCartForCustomerByVendorRow
	for rows.Next() {
		var i GetViewCartForCustomerByVendorRow
		if err := rows.Scan(
			&i.PriceTierID,
			&i.Product.ID,
			&i.Product.Title,
			&i.Product.Description,
			&i.Product.CategoryID,
			&i.Product.Inventory,
			&i.Product.ShipsFrom,
			&i.Product.ShipsTo,
			&i.Product.VendorID,
			&i.Product.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.PasswordHash,
			&i.User.PgpKey,
			&i.User.PrevLogin,
			&i.User.Locale,
			&i.User.Currency,
			&i.User.TwofaEnabled,
			&i.User.IncognitoEnabled,
			&i.User.CreatedAt,
			&i.PriceCent,
			&i.Quantity,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewOrder = `-- name: GetViewOrder :one
SELECT orders.id, orders.status, orders.details, orders.total_price_pico, orders.delivery_method_id, orders.vendor_id, orders.terms_of_service_id, orders.customer_id, orders.num_extends, orders.created_at, orders.paid_at, orders.accepted_at, orders.dispatched_at, orders.finalized_at, orders.disputed_at, 
	dm.id, dm.vendor_id, dm.description, dm.price_cent, dm.deleted_at, 
	customer.id, customer.username, customer.password_hash, customer.pgp_key, customer.prev_login, customer.locale, customer.currency, customer.twofa_enabled, customer.incognito_enabled, customer.created_at,
	vendor.id, vendor.username, vendor.password_hash, vendor.pgp_key, vendor.prev_login, vendor.locale, vendor.currency, vendor.twofa_enabled, vendor.incognito_enabled, vendor.created_at
FROM orders
JOIN delivery_methods AS dm ON dm.id = orders.delivery_method_id
JOIN users AS customer ON customer.id = orders.customer_id
JOIN users AS vendor ON vendor.id = orders.vendor_id
WHERE orders.id = $1
`

type GetViewOrderRow struct {
	Order          Order
	DeliveryMethod DeliveryMethod
	User           User
	User_2         User
}

func (q *Queries) GetViewOrder(ctx context.Context, id uuid.UUID) (GetViewOrderRow, error) {
	row := q.db.QueryRow(ctx, getViewOrder, id)
	var i GetViewOrderRow
	err := row.Scan(
		&i.Order.ID,
		&i.Order.Status,
		&i.Order.Details,
		&i.Order.TotalPricePico,
		&i.Order.DeliveryMethodID,
		&i.Order.VendorID,
		&i.Order.TermsOfServiceID,
		&i.Order.CustomerID,
		&i.Order.NumExtends,
		&i.Order.CreatedAt,
		&i.Order.PaidAt,
		&i.Order.AcceptedAt,
		&i.Order.DispatchedAt,
		&i.Order.FinalizedAt,
		&i.Order.DisputedAt,
		&i.DeliveryMethod.ID,
		&i.DeliveryMethod.VendorID,
		&i.DeliveryMethod.Description,
		&i.DeliveryMethod.PriceCent,
		&i.DeliveryMethod.DeletedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.PasswordHash,
		&i.User.PgpKey,
		&i.User.PrevLogin,
		&i.User.Locale,
		&i.User.Currency,
		&i.User.TwofaEnabled,
		&i.User.IncognitoEnabled,
		&i.User.CreatedAt,
		&i.User_2.ID,
		&i.User_2.Username,
		&i.User_2.PasswordHash,
		&i.User_2.PgpKey,
		&i.User_2.PrevLogin,
		&i.User_2.Locale,
		&i.User_2.Currency,
		&i.User_2.TwofaEnabled,
		&i.User_2.IncognitoEnabled,
		&i.User_2.CreatedAt,
	)
	return i, err
}

const getViewOrdersForCustomer = `-- name: GetViewOrdersForCustomer :many
SELECT orders.id, orders.status, orders.details, orders.total_price_pico, orders.delivery_method_id, orders.vendor_id, orders.terms_of_service_id, orders.customer_id, orders.num_extends, orders.created_at, orders.paid_at, orders.accepted_at, orders.dispatched_at, orders.finalized_at, orders.disputed_at, 
	dm.id, dm.vendor_id, dm.description, dm.price_cent, dm.deleted_at,
	customer.id, customer.username, customer.password_hash, customer.pgp_key, customer.prev_login, customer.locale, customer.currency, customer.twofa_enabled, customer.incognito_enabled, customer.created_at,
	vendor.id, vendor.username, vendor.password_hash, vendor.pgp_key, vendor.prev_login, vendor.locale, vendor.currency, vendor.twofa_enabled, vendor.incognito_enabled, vendor.created_at
FROM orders
JOIN delivery_methods AS dm ON dm.id = orders.delivery_method_id
JOIN users AS customer ON customer.id = orders.customer_id
JOIN users AS vendor ON vendor.id = orders.vendor_id
WHERE orders.customer_id = $1
`

type GetViewOrdersForCustomerRow struct {
	Order          Order
	DeliveryMethod DeliveryMethod
	User           User
	User_2         User
}

func (q *Queries) GetViewOrdersForCustomer(ctx context.Context, customerID uuid.UUID) ([]GetViewOrdersForCustomerRow, error) {
	rows, err := q.db.Query(ctx, getViewOrdersForCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewOrdersForCustomerRow
	for rows.Next() {
		var i GetViewOrdersForCustomerRow
		if err := rows.Scan(
			&i.Order.ID,
			&i.Order.Status,
			&i.Order.Details,
			&i.Order.TotalPricePico,
			&i.Order.DeliveryMethodID,
			&i.Order.VendorID,
			&i.Order.TermsOfServiceID,
			&i.Order.CustomerID,
			&i.Order.NumExtends,
			&i.Order.CreatedAt,
			&i.Order.PaidAt,
			&i.Order.AcceptedAt,
			&i.Order.DispatchedAt,
			&i.Order.FinalizedAt,
			&i.Order.DisputedAt,
			&i.DeliveryMethod.ID,
			&i.DeliveryMethod.VendorID,
			&i.DeliveryMethod.Description,
			&i.DeliveryMethod.PriceCent,
			&i.DeliveryMethod.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.PasswordHash,
			&i.User.PgpKey,
			&i.User.PrevLogin,
			&i.User.Locale,
			&i.User.Currency,
			&i.User.TwofaEnabled,
			&i.User.IncognitoEnabled,
			&i.User.CreatedAt,
			&i.User_2.ID,
			&i.User_2.Username,
			&i.User_2.PasswordHash,
			&i.User_2.PgpKey,
			&i.User_2.PrevLogin,
			&i.User_2.Locale,
			&i.User_2.Currency,
			&i.User_2.TwofaEnabled,
			&i.User_2.IncognitoEnabled,
			&i.User_2.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewOrdersForVendor = `-- name: GetViewOrdersForVendor :many
SELECT orders.id, orders.status, orders.details, orders.total_price_pico, orders.delivery_method_id, orders.vendor_id, orders.terms_of_service_id, orders.customer_id, orders.num_extends, orders.created_at, orders.paid_at, orders.accepted_at, orders.dispatched_at, orders.finalized_at, orders.disputed_at, 
	dm.id, dm.vendor_id, dm.description, dm.price_cent, dm.deleted_at,
	customer.id, customer.username, customer.password_hash, customer.pgp_key, customer.prev_login, customer.locale, customer.currency, customer.twofa_enabled, customer.incognito_enabled, customer.created_at,
	vendor.id, vendor.username, vendor.password_hash, vendor.pgp_key, vendor.prev_login, vendor.locale, vendor.currency, vendor.twofa_enabled, vendor.incognito_enabled, vendor.created_at
FROM orders
JOIN delivery_methods AS dm ON dm.id = orders.delivery_method_id
JOIN users AS customer ON customer.id = orders.customer_id
JOIN users AS vendor ON vendor.id = orders.vendor_id
WHERE orders.vendor_id = $1
`

type GetViewOrdersForVendorRow struct {
	Order          Order
	DeliveryMethod DeliveryMethod
	User           User
	User_2         User
}

func (q *Queries) GetViewOrdersForVendor(ctx context.Context, vendorID uuid.UUID) ([]GetViewOrdersForVendorRow, error) {
	rows, err := q.db.Query(ctx, getViewOrdersForVendor, vendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewOrdersForVendorRow
	for rows.Next() {
		var i GetViewOrdersForVendorRow
		if err := rows.Scan(
			&i.Order.ID,
			&i.Order.Status,
			&i.Order.Details,
			&i.Order.TotalPricePico,
			&i.Order.DeliveryMethodID,
			&i.Order.VendorID,
			&i.Order.TermsOfServiceID,
			&i.Order.CustomerID,
			&i.Order.NumExtends,
			&i.Order.CreatedAt,
			&i.Order.PaidAt,
			&i.Order.AcceptedAt,
			&i.Order.DispatchedAt,
			&i.Order.FinalizedAt,
			&i.Order.DisputedAt,
			&i.DeliveryMethod.ID,
			&i.DeliveryMethod.VendorID,
			&i.DeliveryMethod.Description,
			&i.DeliveryMethod.PriceCent,
			&i.DeliveryMethod.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.PasswordHash,
			&i.User.PgpKey,
			&i.User.PrevLogin,
			&i.User.Locale,
			&i.User.Currency,
			&i.User.TwofaEnabled,
			&i.User.IncognitoEnabled,
			&i.User.CreatedAt,
			&i.User_2.ID,
			&i.User_2.Username,
			&i.User_2.PasswordHash,
			&i.User_2.PgpKey,
			&i.User_2.PrevLogin,
			&i.User_2.Locale,
			&i.User_2.Currency,
			&i.User_2.TwofaEnabled,
			&i.User_2.IncognitoEnabled,
			&i.User_2.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
