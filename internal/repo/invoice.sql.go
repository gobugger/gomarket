// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoice.sql

package repo

import (
	"context"

	"github.com/google/uuid"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
	amount_pico, permanent
) VALUES(
	$1, $2
) RETURNING id, address, amount_pico, status, amount_unlocked_pico, permanent, created_at
`

type CreateInvoiceParams struct {
	AmountPico int64
	Permanent  bool
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice, arg.AmountPico, arg.Permanent)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM invoices
WHERE id = $1
`

func (q *Queries) DeleteInvoice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoice, id)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT id, address, amount_pico, status, amount_unlocked_pico, permanent, created_at FROM invoices 
WHERE id = $1
`

func (q *Queries) GetInvoice(ctx context.Context, id uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const getInvoiceForOrder = `-- name: GetInvoiceForOrder :one
SELECT invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at 
FROM order_invoices
JOIN invoices ON invoices.id = order_invoices.invoice_id
WHERE order_invoices.order_id = $1
`

func (q *Queries) GetInvoiceForOrder(ctx context.Context, orderID uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceForOrder, orderID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const getInvoiceForWallet = `-- name: GetInvoiceForWallet :one
SELECT invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at
FROM deposits
JOIN invoices ON invoices.id = deposits.invoice_id
WHERE deposits.wallet_id = $1
`

func (q *Queries) GetInvoiceForWallet(ctx context.Context, walletID uuid.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceForWallet, walletID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const getInvoicesWithoutAddress = `-- name: GetInvoicesWithoutAddress :many
SELECT invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at 
FROM invoices
WHERE address = ''
`

func (q *Queries) GetInvoicesWithoutAddress(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesWithoutAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.AmountPico,
			&i.Status,
			&i.AmountUnlockedPico,
			&i.Permanent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvoices = `-- name: GetPendingInvoices :many
SELECT invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at 
FROM invoices
WHERE status = 'pending'::invoice_status AND address != ''
`

func (q *Queries) GetPendingInvoices(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getPendingInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.AmountPico,
			&i.Status,
			&i.AmountUnlockedPico,
			&i.Permanent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpreparedInvoices = `-- name: GetUnpreparedInvoices :many
SELECT invoices.id, invoices.address, invoices.amount_pico, invoices.status, invoices.amount_unlocked_pico, invoices.permanent, invoices.created_at
FROM invoices
WHERE status = 'pending'::invoice_status AND address = ''
FOR UPDATE
`

func (q *Queries) GetUnpreparedInvoices(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getUnpreparedInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.AmountPico,
			&i.Status,
			&i.AmountUnlockedPico,
			&i.Permanent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setInvoiceAddress = `-- name: SetInvoiceAddress :one
UPDATE invoices
SET address = $2
WHERE id = $1 AND address = '' AND LENGTH($2) = 95
RETURNING id, address, amount_pico, status, amount_unlocked_pico, permanent, created_at
`

type SetInvoiceAddressParams struct {
	ID      uuid.UUID
	Address string
}

func (q *Queries) SetInvoiceAddress(ctx context.Context, arg SetInvoiceAddressParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, setInvoiceAddress, arg.ID, arg.Address)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const updateInvoiceAmountUnlocked = `-- name: UpdateInvoiceAmountUnlocked :one
UPDATE invoices
SET amount_unlocked_pico = $2
WHERE id = $1
RETURNING id, address, amount_pico, status, amount_unlocked_pico, permanent, created_at
`

type UpdateInvoiceAmountUnlockedParams struct {
	ID                 uuid.UUID
	AmountUnlockedPico int64
}

func (q *Queries) UpdateInvoiceAmountUnlocked(ctx context.Context, arg UpdateInvoiceAmountUnlockedParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceAmountUnlocked, arg.ID, arg.AmountUnlockedPico)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
UPDATE invoices
SET status = $2
WHERE id = $1
RETURNING id, address, amount_pico, status, amount_unlocked_pico, permanent, created_at
`

type UpdateInvoiceStatusParams struct {
	ID     uuid.UUID
	Status InvoiceStatus
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.ID, arg.Status)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.AmountPico,
		&i.Status,
		&i.AmountUnlockedPico,
		&i.Permanent,
		&i.CreatedAt,
	)
	return i, err
}
